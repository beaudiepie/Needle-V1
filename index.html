<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Progressive Indicator</title>
  <style>
    :root{
      --bg:#0b0c10; --text:#e6e8ec; --muted:#a3adbd;
      --on-start:#22c55e;  --on-end:#16a34a;   /* active gradient */
      --off-start:#ef4444; --off-end:#b91c1c;  /* inactive gradient */
      --on-glow: rgba(34,197,94,.55);
      --off-glow-strong: rgba(239,68,68,.95);  /* strong red flash glow */
    }
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; display:grid; place-items:center;
      background: radial-gradient(1200px 800px at 50% 10%, #121725, var(--bg));
      color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial;
    }
    .card{width:min(760px,96vw); padding:22px; border-radius:24px;
      background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04);
    }
    h1{margin:0 0 6px; font-size:18px}
    .sub{margin:0 0 12px; color:var(--muted); font-size:13px}

    svg{display:block; width:100%; height:auto}

    /* Base (red) slices live under green overlays */
    .slice-base{ cursor:pointer; transition: filter 300ms ease; }
    .slice-base.flash{ animation: flashRed 480ms ease-in-out infinite; filter: drop-shadow(0 0 26px var(--off-glow-strong)); }

    @keyframes flashRed{
      0%,100%{ filter: drop-shadow(0 0 12px rgba(239,68,68,.65)); }
      50%   { filter: drop-shadow(0 0 32px rgba(239,68,68,1)); }
    }

    /* Green overlays default invisible; we animate their opacity */
    .slice-on{ opacity:0; pointer-events:none; /* clicks pass to base */
      transition: opacity 320ms ease; }
    .slice-on.glow{ filter: drop-shadow(0 0 18px var(--on-glow)); }

    /* Group flash when 6 is full */
    #slices-on.green-flash{ animation: greenFlash 600ms ease-in-out 2; }
    @keyframes greenFlash{
      0%,100%{ filter: drop-shadow(0 0 12px rgba(34,197,94,.6)); }
      50%   { filter: drop-shadow(0 0 34px rgba(34,197,94,1)); }
    }

    /* Letters appearing over slices */
    .letter{ fill:#fff; stroke:#0b0c10; stroke-width:1.5; font-weight:900; font-size:26px; letter-spacing:.4px;
      opacity:0; transition: opacity 360ms ease; pointer-events:none; }

    /* Switchboard controls: smaller & more grouped */
    .panel{
      margin-top:12px; display:grid; gap:10px;
      grid-template-columns: repeat(3, 64px);
      justify-content:center; align-items:center;
    }
    .btn{
      aspect-ratio:1/1;
      width:clamp(44px, 9vw, 64px);
      border-radius:999px; display:grid; place-items:center;
      border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06);
      color:var(--text); font-weight:800; font-size:16px; cursor:pointer;
      box-shadow: inset 0 2px 4px rgba(255,255,255,.06), 0 6px 16px rgba(0,0,0,.35);
      transition: transform .12s ease, background .2s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .btn:hover{ transform: translateY(-2px); background:rgba(255,255,255,.1); }
    /* Pressed-in state */
    .btn.pressed{
      transform: translateY(2px) scale(.98);
      background: rgba(255,255,255,.12);
      box-shadow: inset 0 4px 10px rgba(0,0,0,.45), 0 2px 6px rgba(0,0,0,.25);
      border-color: rgba(255,255,255,.22);
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Half‑Pizza Progressive Indicator</h1>
    <p class="sub">Press 1–6 to fill progressively. Press 0 to trigger a strong red flash for 3s. The pressed button stays pushed‑in while active.</p>

    <svg viewBox="0 0 800 420" role="img" aria-label="Six slice half pizza indicator">
      <defs>
        <linearGradient id="grad-on" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%" stop-color="var(--on-start)"/>
          <stop offset="100%" stop-color="var(--on-end)"/>
        </linearGradient>
        <linearGradient id="grad-off" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%" stop-color="var(--off-start)"/>
          <stop offset="100%" stop-color="var(--off-end)"/>
        </linearGradient>
      </defs>
      <!-- Two layers: red base underneath, green overlays on top -->
      <g id="slices-base" stroke="#0b0c10" stroke-width="8"></g>
      <g id="slices-on" stroke="#0b0c10" stroke-width="8"></g>
      <!-- Letters overlay -->
      <g id="letters"></g>
    </svg>

    <div class="panel">
      <button class="btn" data-set="0" aria-pressed="false">0</button>
      <button class="btn" data-set="1" aria-pressed="false">1</button>
      <button class="btn" data-set="2" aria-pressed="false">2</button>
      <button class="btn" data-set="3" aria-pressed="false">3</button>
      <button class="btn" data-set="4" aria-pressed="false">4</button>
      <button class="btn" data-set="5" aria-pressed="false">5</button>
      <button class="btn" data-set="6" aria-pressed="false">6</button>
    </div>
  </div>

  <script>
    // ===== Geometry & Config =====
    const COUNT = 6;
    const CX = 400, CY = 420, R = 260;
    const START = -180, SWEEP = 180, GAP = 6, THICKNESS = 90;

    // Animation timings
    const STEP_DELAY = 160;   // delay between each slice fading in/out
    const HOLD_MS    = 3000;  // how long to hold fully shown state
    const FLASH_MS   = 3000;  // red flash duration
    const GREEN_FLASH_MS = 1200; // flash duration when full (6) is reached

    const baseG = document.getElementById('slices-base');
    const onG   = document.getElementById('slices-on');
    const lettersG = document.getElementById('letters');

    const baseEls = []; // red base slices
    const onEls   = []; // green overlay slices
    const letterEls = []; // P L A C E S

    let timers = [];    // queued setTimeout handles
    let holdTimer = null;
    let flashTimer = null;
    let releaseTimer = null;  // for releasing pressed button
    let activeBtn = null;     // currently pressed button element

    const toRad = d => (d * Math.PI) / 180;
    function polar(cx, cy, r, a){ return { x: cx + r * Math.cos(toRad(a)), y: cy + r * Math.sin(toRad(a)) }; }
    function wedgePath(cx, cy, rOuter, thickness, a0, a1){
      const rInner = rOuter - thickness;
      const p0 = polar(cx, cy, rInner, a0);
      const p1 = polar(cx, cy, rOuter, a0);
      const p2 = polar(cx, cy, rOuter, a1);
      const p3 = polar(cx, cy, rInner, a1);
      return `M ${p0.x} ${p0.y} L ${p1.x} ${p1.y} A ${rOuter} ${rOuter} 0 0 1 ${p2.x} ${p2.y} L ${p3.x} ${p3.y} A ${rInner} ${rInner} 0 0 0 ${p0.x} ${p0.y} Z`;
    }

    // Build slices (base + overlay per segment) + letter placeholders
    const per = SWEEP / COUNT;
    const letters = 'PLACES'.split('');
    for(let i=0;i<COUNT;i++){
      const a0 = START + per*i + GAP/2;
      const a1 = START + per*(i+1) - GAP/2;
      const d  = wedgePath(CX, CY, R, THICKNESS, a0, a1);

      // Base (red)
      const base = document.createElementNS('http://www.w3.org/2000/svg','path');
      base.setAttribute('d', d);
      base.setAttribute('fill','url(#grad-off)');
      base.setAttribute('class','slice-base');
      base.dataset.index = (i+1).toString();
      base.addEventListener('click', ()=> animateTo(i+1));
      baseG.appendChild(base);
      baseEls.push(base);

      // Overlay (green)
      const on = document.createElementNS('http://www.w3.org/2000/svg','path');
      on.setAttribute('d', d);
      on.setAttribute('fill','url(#grad-on)');
      on.setAttribute('class','slice-on');
      on.style.opacity = 0;
      onG.appendChild(on);
      onEls.push(on);

      // Letters
      const mid = (a0 + a1) / 2;
      const tp = polar(CX, CY, R - (THICKNESS/2) - 14, mid);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', tp.x);
      t.setAttribute('y', tp.y);
      t.setAttribute('text-anchor','middle');
      t.setAttribute('dominant-baseline','middle');
      t.setAttribute('class','letter');
      t.textContent = letters[i];
      lettersG.appendChild(t);
      letterEls.push(t);
    }

    // ===== Button press visuals =====
    function pressButton(btn){
      if(activeBtn && activeBtn !== btn){ releaseButton(); }
      activeBtn = btn;
      activeBtn.classList.add('pressed');
      activeBtn.setAttribute('aria-pressed','true');
    }
    function releaseButton(){
      if(activeBtn){
        activeBtn.classList.remove('pressed');
        activeBtn.setAttribute('aria-pressed','false');
        activeBtn = null;
      }
      if(releaseTimer){ clearTimeout(releaseTimer); releaseTimer = null; }
    }
    function scheduleRelease(ms){
      if(releaseTimer) { clearTimeout(releaseTimer); }
      releaseTimer = setTimeout(()=>{ releaseButton(); }, ms);
    }

    // ===== Animation control =====
    function clearAllTimers(){
      timers.forEach(t=> clearTimeout(t));
      timers = [];
      if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
      if(flashTimer){ clearTimeout(flashTimer); flashTimer = null; }
      if(releaseTimer){ clearTimeout(releaseTimer); releaseTimer = null; }
    }
    function stopFlash(){ baseEls.forEach(b=> b.classList.remove('flash')); onG.classList.remove('green-flash'); }

    function showPlaces(){ letterEls.forEach(el=> el.style.opacity = 1); }
    function hidePlaces(){ letterEls.forEach(el=> el.style.opacity = 0); }

    function setOpacityUpTo(n, op){
      for(let i=0;i<COUNT;i++){
        onEls[i].style.opacity = i < n ? op : 0;
        onEls[i].classList.toggle('glow', i < n && op > 0);
      }
    }

    function animateTo(n){
      n = Math.max(1, Math.min(COUNT, n));
      clearAllTimers();
      stopFlash();
      hidePlaces();
      // reset overlays to current state (all off before animating up)
      setOpacityUpTo(0, 0);

      // progressive fade-in one by one
      for(let i=0;i<n;i++){
        const h = setTimeout(()=>{
          onEls[i].style.opacity = 1;
          onEls[i].classList.add('glow');
        }, i * STEP_DELAY);
        timers.push(h);
      }

      // after last slice has faded in
      const lastInAt = (n-1) * STEP_DELAY + 320; // 320 ~= CSS opacity transition ms

      if(n === 6){
        // brief green flash and reveal PLACES
        const flashStart = lastInAt;
        const startFlash = setTimeout(()=>{ onG.classList.add('green-flash'); }, flashStart);
        const endFlash = setTimeout(()=>{ onG.classList.remove('green-flash'); }, flashStart + GREEN_FLASH_MS);
        const showLetters = setTimeout(()=>{ showPlaces(); }, flashStart + 200);
        timers.push(startFlash, endFlash, showLetters);
      }

      // start hold, then fade down
      holdTimer = setTimeout(()=>{ 
        // hide letters just before fading down
        hidePlaces();
        fadeDown(n); 
      }, lastInAt + HOLD_MS);

      // total duration to keep button pressed = fade-in + hold + fade-out
      const fadeOutDur = (n-1) * STEP_DELAY + 320;
      scheduleRelease(lastInAt + HOLD_MS + fadeOutDur);
    }

    function fadeDown(fromN){
      // fade back down to default (all red). We'll go in reverse, one by one.
      for(let i=fromN-1, step=0; i>=0; i--, step++){
        const h = setTimeout(()=>{
          onEls[i].style.opacity = 0;
          onEls[i].classList.remove('glow');
        }, step * STEP_DELAY);
        timers.push(h);
      }
    }

    function flashRed(){
      clearAllTimers();
      hidePlaces();
      // ensure green overlays are hidden
      setOpacityUpTo(0,0);
      // start flashing strong red on all base segments
      baseEls.forEach(b=> b.classList.add('flash'));
      // stop flashing after FLASH_MS
      flashTimer = setTimeout(()=>{ stopFlash(); }, FLASH_MS);
      // keep button pressed during flash
      scheduleRelease(FLASH_MS);
    }

    // Public helpers
    window.setSlice = animateTo; // keep same external API name
    window.clearSlices = ()=>{ clearAllTimers(); stopFlash(); setOpacityUpTo(0,0); hidePlaces(); releaseButton(); };
    window.flashRed = flashRed;

    // Buttons
    document.querySelectorAll('.btn[data-set]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const val = parseInt(btn.dataset.set,10);
        pressButton(btn);
        if(val === 0) flashRed(); else animateTo(val);
      });
    });

    // Default: all red
    setOpacityUpTo(0,0);
    hidePlaces();
  </script>
</body>
</html>




